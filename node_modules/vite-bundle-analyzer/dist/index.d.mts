// dprint-ignore
type DeepPartial<T> = T extends object ? {
  [P in keyof T]?: DeepPartial<T[P]>
} :
  T



type Empty = NonNullable<unknown>

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type Any = any


import type { BrotliOptions } from 'zlib';
import { createFilter } from '@rollup/pluginutils';
import { CreateServerContext as CreateServerContext_2 } from './render';
import type { FilterPattern } from '@rollup/pluginutils';
import type { HookHandler } from 'vite';
import http from 'http';
import { InputType } from 'zlib';
import { Plugin as Plugin_2 } from 'vite';
import type { Plugin as Plugin_3 } from 'rollup';
import type { Plugin as Plugin_4 } from 'rolldown';
import { Readable } from 'stream';
import type { ZlibOptions } from 'zlib';

export declare function adapter(userPlugin: Plugin_2<AnalyzerPluginInternalAPI>): Pick<Plugin_2<AnalyzerPluginInternalAPI>, "closeBundle" | "generateBundle" | "name" | "api"> | Plugin_3<any>;

declare const ALLOWED_MAGIC_TYPE: readonly ["graph:click", "client:ready", "send:ui", "send:filter"];

export declare type AllowedMagicType = typeof ALLOWED_MAGIC_TYPE[number];

declare function analyzer(opts?: AnalyzerPluginOptions): Plugin_2<AnalyzerPluginInternalAPI>;
export { analyzer }
export default analyzer;

export declare type AnalyzerMode = 'static' | 'json' | 'server';

declare class AnalyzerModule {
    compressAlorithm: ReturnType<typeof createCompressAlorithm>;
    modules: AnalyzerNode[];
    workspaceRoot: string;
    pluginContext: PluginContext | null;
    private chunks;
    private matcher;
    constructor(opt?: AnalyzerModuleOptions);
    installPluginContext(context: PluginContext): void;
    setupRollupChunks(chunks: OutputBundle): void;
    addModule(mod: OutputChunk | OutputAsset): Promise<void>;
    processModule(): Module[];
}

declare interface AnalyzerModuleOptions {
    gzip?: ZlibOptions;
    brotli?: BrotliOptions;
    include?: FilterPattern;
    exclude?: FilterPattern;
}

declare class AnalyzerNode {
    originalId: string;
    filename: string;
    label: string;
    parsedSize: number;
    mapSize: number;
    statSize: number;
    gzipSize: number;
    brotliSize: number;
    source: Array<GroupWithNode>;
    stats: Array<GroupWithNode>;
    imports: Set<string>;
    isAsset: boolean;
    isEntry: boolean;
    constructor(originalId: string);
    private addImports;
    setup(mod: SerializedMod, pluginContext: PluginContext, compress: ReturnType<typeof createCompressAlorithm>, workspaceRoot: string, matcher: ReturnType<typeof createFilter>): Promise<void>;
}

export declare interface AnalyzerPluginInternalAPI {
    store: AnalyzerStore;
    processModule(): Module[];
}

export declare type AnalyzerPluginOptions = AnalyzerPluginOptionsWithServer | AnalyzerPluginOptionsWithStatic | AnalyzerPluginOptionsWithJson | AnalyzerPluginOptionsWithCustom;

declare interface AnalyzerPluginOptionsWithCustom extends BasicAnalyzerPluginOptions {
    analyzerMode: CustomAnalyzerModule;
}

declare interface AnalyzerPluginOptionsWithJson extends BasicAnalyzerPluginOptions {
    analyzerMode?: 'json';
    fileName?: string | FileNameDesc;
}

declare interface AnalyzerPluginOptionsWithServer extends BasicAnalyzerPluginOptions {
    analyzerMode?: 'server';
    analyzerPort?: number | 'auto';
    openAnalyzer?: boolean;
}

declare interface AnalyzerPluginOptionsWithStatic extends BasicAnalyzerPluginOptions {
    analyzerMode?: 'static';
    analyzerPort?: number | 'auto';
    openAnalyzer?: boolean;
    fileName?: string | FileNameDesc;
}

declare interface AnalyzerStore {
    analyzerModule: AnalyzerModule;
    lastSourcemapOption: boolean;
    hasSetupSourcemapOption: boolean;
    pluginOptions: AnalyzerPluginOptions;
    preferLivingServer: boolean;
    preferSilent: boolean;
}

declare function arena(): {
    rs: Readable;
    into(b: string | Uint8Array): void;
    refresh(data?: string | Uint8Array): void;
};

declare interface BasicAnalyzerPluginOptions {
    enabled?: boolean;
    summary?: boolean;
    include?: FilterPattern;
    exclude?: FilterPattern;
    analyzerMode?: AnalyzerMode | CustomAnalyzerModule;
    reportTitle?: string;
    defaultSizes?: DefaultSizes;
    gzipOptions?: ZlibOptions;
    brotliOptions?: BrotliOptions;
}

export declare interface C {
    req: http.IncomingMessage;
    res: http.ServerResponse;
    query: Record<string, string>;
    params: Record<string, string>;
}

export declare function createAnalyzerServer(analyzeModule: Module[], opts: AnalyzerPluginOptions, b: ReturnType<typeof arena>, callCount: number, sseHandler?: {
    path: string;
    handler: Middleware;
}, render?: typeof renderView): Promise<{
    server: CreateServerContext_2;
    port: number;
}>;

declare function createCompressAlorithm(opt: AnalyzerModuleOptions): {
    gzip: (buf: InputType) => Promise<Buffer<ArrayBufferLike>>;
    brotli: (buf: InputType) => Promise<Buffer<ArrayBufferLike>>;
};

export declare function createServer(): CreateServerContext;

export declare interface CreateServerContext {
    use: (middleware: Middleware) => void;
    get: (path: string, middleware: Middleware) => void;
    listen: (port: number, callback?: () => void) => void;
}

declare type CustomAnalyzerModule = (analyzeModule: Module[]) => void;

export declare type DefaultSizes = 'stat' | 'parsed' | 'gzip' | 'brotli';

export declare interface Descriptor {
    kind: 'script' | 'style' | 'title';
    text: string;
    attrs?: string[];
}

export declare interface Descriptor {
    kind: 'script' | 'style' | 'title';
    text: string;
    attrs?: string[];
}

export declare function ensureEmptyPort(preferredPort: number): Promise<number>;

declare type FileNameDesc = (outputDir: string) => string;

declare type GenerateBundleFunction = NonNullable<HookHandler<Plugin_2['generateBundle']>>;

declare interface GroupWithNode {
    groups: Array<GroupWithNode>;
    children?: Map<string, Node_2>;
    filename: string;
    label: string;
    [prop: string]: Any;
}

export declare function handleStaticOutput(analyzeModule: Module[], opts: AnalyzerPluginOptions, defaultWd: string, b: ReturnType<typeof arena>): Promise<{
    filePath: string;
    isJSON: boolean;
    html?: undefined;
} | {
    filePath: string;
    isJSON: boolean;
    html: string;
}>;

export declare function injectHTMLTag(options: InjectHTMLTagOptions): string;

declare interface InjectHTMLTagOptions {
    html: string;
    injectTo: 'body' | 'head';
    descriptors: Descriptor | Descriptor[];
}

export declare const isCI: boolean;

export declare type Middleware = (c: C, next: () => void) => void;

export declare interface Module {
    label: string;
    filename: string;
    isEntry: boolean;
    statSize: number;
    parsedSize: number;
    mapSize: number;
    gzipSize: number;
    brotliSize: number;
    source: Array<Module>;
    stats: Array<Module>;
    imports: Array<string>;
    groups: Array<Module>;
    isAsset?: boolean;
}

declare type Module_2 = typeof window['analyzeModule'][number];

declare class Node_2<T = Empty> implements NodeDescriptor<T> {
    meta: T;
    filename: string;
    children: Map<string, Node_2<T>>;
    groups: Array<GroupWithNode>;
    isEndOfPath: boolean;
    constructor(options?: Partial<NodeDescriptor<T>>);
}

declare interface NodeDescriptor<T = Record<string, Empty>> {
    meta: T;
    filename: string;
}

export declare function openBrowser(address: string): void;

declare type OutputAsset = Extract<OutputBundle[0], {
    type: 'asset';
}>;

declare type OutputBundle = Parameters<GenerateBundleFunction>[1];

declare type OutputChunk = Extract<OutputBundle[0], {
    type: 'chunk';
}>;

declare type PluginContext = ThisParameterType<RenderChunkFunction>;

export declare type QueryKind = 'gzip' | 'stat' | 'parsed';

declare type RenderChunkFunction = NonNullable<HookHandler<Plugin_2['renderChunk']>>;

export declare interface RenderOptions {
    title: string;
    mode: DefaultSizes;
}

export declare function renderView(analyzeModule: Module[], options: RenderOptions): Promise<string>;

export declare interface SendFilterMessage {
    analyzeModule: Module_2[];
}

export declare interface SendUIMessage {
    Component: () => JSX.Element;
    type: 'SideBar' | 'Main';
}

declare type SerializedMod = SerializedModWithAsset | SerializedModWithChunk;

declare interface SerializedModWithAsset {
    code: Uint8Array;
    filename: string;
    kind: 'asset';
}

declare interface SerializedModWithChunk {
    code: Uint8Array;
    filename: string;
    map: string;
    imports: string[];
    dynamicImports: string[];
    moduleIds: string[];
    isEntry: boolean;
    kind: 'chunk';
}

export declare class SSE {
    private activeStreams;
    serverEventStream(req: http.IncomingMessage, res: http.ServerResponse): void;
    sendEvent(event: string, data: string): void;
    private removeStream;
}

export declare interface SSEMessageBody {
    event: string;
    data: string;
}

export declare function unstableRolldownAdapter(userPlugin: Plugin_2<AnalyzerPluginInternalAPI>): Pick<Plugin_2<AnalyzerPluginInternalAPI>, "generateBundle" | "name" | "api"> | Plugin_4<any>;

export { }
